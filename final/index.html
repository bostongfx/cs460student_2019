<!DOCTYPE html>
<html>

<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <link rel="shortcut icon" href="gfx/cs460.png" type="image/gif">
    <link rel="stylesheet" href="styles.css">

    <title>CS460 Final</title>
    <script src="https://threejs.org/examples/js/libs/dat.gui.min.js" type="text/javascript"></script>
    <script async src="opencv.js" onload="openCvReady();" type="text/javascript"></script>

</head>

<body>
    <header>
      <h1>opencv image processing</h1>
      <div id="logo"><img style="height:60px" src="gfx/cs460.png"></div>
    </header>

  <div id="status" class="loader"></div>

  <img id='srcImage' style="display:none;"></img>

  <div style="margin-bottom:30px;">
    <table id="imageTable" width="75%" cellspacing="0" cellpadding="0" border="0" style="display:none;">
    <tbody>
      <tr>
        <td>
          <input type='file' id='fileInput' accept='image/*'/>
        </td>
      </tr>
      <tr>
        <td style="width:100%">
              <canvas id='outputCanvas'></canvas>
        </td>
    </tr>
    <tr>
      <td style="width:40%padding: 10px 0px 0px 10px;">
        <button class="button" type="button" id="resetBtn" onclick="reset()">Reset</button>
        <a class="button" id="dl" onclick="exportImg()"><button type="button">Export</button></a>
      </td>
      <td id="srcErr"></td>
    </tr>
    </tbody>
  </table>
</div>
  </body>
  <script type="text/javascript">
      let imgElement = document.getElementById('srcImage');
      let inputElement = document.getElementById('fileInput');
      inputElement.addEventListener("change", (e) => {
          imgElement.src = URL.createObjectURL(e.target.files[0]);
      }, false);

      imgElement.onload = function() {
          let mat = cv.imread(imgElement);
          cv.imshow('outputCanvas', mat);
          mat.delete();
      };

      gray = false;
      hsv = false;

      function openCvReady() {
        cv['onRuntimeInitialized']=()=>{
          console.log( 'OpenCV Ready', cv);
          document.getElementById('status').style.display = 'none';
          document.getElementById('imageTable').style.display = 'block';

          let imgElement = document.getElementById('srcImage')
          imgElement.src = 'gfx/cs460.png';

          imgElement.onload = function() {
              let mat = cv.imread(imgElement);
              cv.imshow('outputCanvas', mat);
              mat.delete();
          };

          var Thresh = function() {
              this.thresh =  127;
              this.alpha =  255;
              this.type = 'Binary';
              this.code = cv.THRESH_BINARY;
              this.otsu = false;
              this.triangle = false;
              this.block = 3;
              this.maxval = 255;
              this.c = 2;
              this.adaptiveM = false;
              this.adaptiveG = false;
              this.adapt = cv.ADAPTIVE_THRESH_MEAN_C
          };

          controller = {
              "Gray": function(){
                  gray = true;
                  if (isCanvasBlank(document.getElementById('outputCanvas'))) {
                      let mat = cv.imread(imgElement);
                      cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY);
                      cv.imshow('outputCanvas', mat);
                      mat.delete();
                  }
                  else {
                      let mat = cv.imread(document.getElementById('outputCanvas'));
                      cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY);
                      cv.imshow('outputCanvas', mat);
                      mat.delete();
                  }
              },
              "HSV": function(){
                  hsv = true;
                  if (isCanvasBlank(document.getElementById('outputCanvas'))) {
                      let mat = cv.imread(imgElement);
                      cv.cvtColor(mat, mat, cv.COLOR_RGB2HSV);
                      cv.imshow('outputCanvas', mat);
                      mat.delete();
                  }
                  else {
                      let mat = cv.imread(document.getElementById('outputCanvas'));
                      cv.cvtColor(mat, mat, cv.COLOR_RGB2HSV);
                      cv.imshow('outputCanvas', mat);
                      mat.delete();
                  }
              }
          }

          var gui = new dat.GUI();
          gui.domElement.id = 'gui';
          var colors = gui.addFolder( "Colors" );
          colors.add( controller, 'Gray' );
          colors.add( controller, 'HSV' );
          colors.add( controller, ['R', 'G', 'B'])
          colors.open();
          var b_threshold = gui.addFolder("Threshold");
          var bin = new Thresh();
          bin.type = cv.THRESH_BINARY;
          var threshType = b_threshold.add(bin, 'type', ['Binary', 'Binary Inv',
             'Trunc', 'To Zero']).name('Type').listen();
          threshType.setValue('Binary');
          var otsu = b_threshold.add(bin, 'otsu').name('Otsu').listen();
          otsu.onChange(function(val){
            bin.otsu = val;
            if(val){
                bin.triangle = false;
            }
            let mat = cv.imread(imgElement);
            cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);
            cv.threshold(mat, mat, bin.thresh, bin.alpha, cv.THRESH_OTSU);
            cv.imshow('outputCanvas', mat);
            mat.delete();
          });
          var triangle = b_threshold.add(bin, 'triangle').name('Triangle').listen();
          triangle.onChange(function(val){
            bin.triangle = val;
            if(val){
                bin.otsu = false;
            }
            let mat = cv.imread(imgElement);
            cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);
            cv.threshold(mat, mat, bin.thresh, bin.alpha, cv.THRESH_TRIANGLE);
            cv.imshow('outputCanvas', mat);
            mat.delete();
          });
          threshType.onChange(function(val) {
              bin.type = val;
              switch(val) {
                  case 'Binary': bin.code = cv.THRESH_BINARY;break;
                  case 'Binary Inv': bin.code = cv.THRESH_BINARY_INV;break;
                  case 'Trunc': bin.code = cv.THRESH_TRUNC;break;
                  case 'To Zero': bin.code = cv.THRESH_TOZERO;break;
              }
          });
          b_threshold.add(bin, 'thresh', 0, 255, 1).name('Thresh').onChange( function(val) {
              let mat = cv.imread(imgElement);
              if (gray) {
                  cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);
              }
              if (hsv) {
                  cv.cvtColor(mat, mat, cv.COLOR_RGB2HSV, 0);
              }
              cv.threshold(mat, mat, val, bin.alpha, bin.code);
              cv.imshow('outputCanvas', mat);
              mat.delete();
          });
          b_threshold.add(bin, 'alpha', 0, 255, 1).name('Max Val').onChange( function(val) {
              // var canvas = document.getElementById('outputCanvas');
              // const context = canvas.getContext('2d', { alpha: false });
              // context.clearRect(0, 0, canvas.width, canvas.height);


              let mat = cv.imread(imgElement);
              if (gray) {
                  cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);
              }
              if (hsv) {
                  cv.cvtColor(mat, mat, cv.COLOR_RGB2HSV, 0);
              }
              cv.threshold(mat, mat, bin.thresh, val, bin.code);

              cv.imshow('outputCanvas', mat);
              mat.delete();
          });
          b_threshold.open();


          var a_threshold = gui.addFolder("Adaptive Thresh (Requires 'Binary'/'Inv')");
          var adaptM = a_threshold.add(bin, 'adaptiveM').name('Adaptive Mean').listen();
          var adaptG = a_threshold.add(bin, 'adaptiveG').name('Adaptive Gau').listen();
          a_threshold.add(bin, 'maxval', 0, 255, 1).name('Max Val').onChange( function(val) {
            let mat = cv.imread(imgElement);
            cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);
            if((bin.adaptiveM || bin.adaptiveG) && (bin.type == 'Binary' || bin.type == 'Binary Inv')){
              if(bin.adaptiveM){
                cv.adaptiveThreshold(mat, mat, val, cv.ADAPTIVE_THRESH_MEAN_C, bin.code, bin.block, bin.c);
              }
              else {
                cv.adaptiveThreshold(mat, mat, val, cv.ADAPTIVE_THRESH_GAUSSIAN_C, bin.code, bin.block, bin.c);
              }
            }
            cv.imshow('outputCanvas', mat);
            mat.delete();
          });

          adaptM.onChange(function(val) {
            bin.adaptiveM = val;
            gray = true;
            if (val) {
              bin.adaptiveG = false;
            }
          });
          adaptG.onChange(function(val) {
            bin.adaptiveG = val;
            gray = true;
            if (val) {
              bin.adaptiveM = false;
            }
          });
          var vals = [];
          for (i = 1; i <= 115; i +=2){
            vals.push(i);
          }
          a_threshold.add(bin, 'block', vals).name('Block Size').onChange( function(val) {
            bin.block = parseInt(val);
              let mat = cv.imread(imgElement);
              cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);

              if((bin.adaptiveM || bin.adaptiveG) && (bin.type == 'Binary' || bin.type == 'Binary Inv')){
                if(bin.adaptiveM){
                  cv.adaptiveThreshold(mat, mat, bin.maxval, cv.ADAPTIVE_THRESH_MEAN_C, bin.code, parseInt(val), bin.c);
                }
                else {
                  cv.adaptiveThreshold(mat, mat, bin.maxval, cv.ADAPTIVE_THRESH_GAUSSIAN_C, bin.code, parseInt(val), bin.c);
                }
              }
              cv.imshow('outputCanvas', mat);
              mat.delete();
          });
          a_threshold.add(bin, 'c', -20, 20, 1).name('C').onChange( function(val) {
              let mat = cv.imread(imgElement);
              cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);

              if((bin.adaptiveM || bin.adaptiveG) && (bin.type == 'Binary' || bin.type == 'Binary Inv')){
                if(bin.adaptiveM){
                  cv.adaptiveThreshold(mat, mat, bin.maxval, cv.ADAPTIVE_THRESH_MEAN_C, bin.code, bin.block, val);
                }
                else {
                  cv.adaptiveThreshold(mat, mat, bin.maxval, cv.ADAPTIVE_THRESH_GAUSSIAN_C, bin.code, bin.block, val);
                }
              }
              cv.imshow('outputCanvas', mat);
              mat.delete();
          });
          a_threshold.open();


          var filter = gui.addFolder("Filters");


        };
      }

      function reset() {
          let mat = cv.imread(imgElement);
          cv.imshow('outputCanvas', mat);
          mat.delete();
          gray = false;
          hsv = false;

      }

      function exportImg() {
          var dl = document.getElementById('dl');
          var canvas = document.getElementById('outputCanvas');
          var dataURL = canvas.toDataURL('image/jpeg', 1.0).replace("image/png", "image/octet-stream");

          dl.setAttribute('download', 'export.png');
          dl.setAttribute('href', dataURL);
      }

      function isCanvasBlank(canvas) {
          const context = canvas.getContext('2d');

          const pixelBuffer = new Uint32Array(
              context.getImageData(0, 0, canvas.width, canvas.height).data.buffer
          );

          return !pixelBuffer.some(color => color !== 0);
      }

  </script>

</html>
