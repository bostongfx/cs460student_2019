<!DOCTYPE html>
<html>

<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <link rel="shortcut icon" href="gfx/cs460.png" type="image/gif">
    <link rel="stylesheet" href="styles.css">

    <title>CS460 Final</title>
    <script src="https://threejs.org/examples/js/libs/dat.gui.min.js" type="text/javascript"></script>
    <script async src="opencv.js" onload="openCvReady();" type="text/javascript"></script>

</head>

<body>
    <header>
      <!-- <h1>opencv image processing</h1> -->
      <div id="logo"><img style="height:60px" src="gfx/cs460.png"></div>
    </header>

    <!-- <p >OpenCV.js is loading...</p> -->
    <div id="status" class="loader"></div>

    <input type='file' id='fileInput' accept='image/*'/>

  <img id='srcImage' style="display:none;"></img>
  <div style="margin-bottom:30px;">
    <table id="imageTable" width="75%" cellspacing="0" cellpadding="0" border="0" style="display:none;">
    <tbody>
      <tr>
        <td style="width:100%">
              <canvas id='outputCanvas'></canvas>
        </td>
    </tr>
    <tr>
      <td style="width:40%padding: 10px 0px 0px 10px;">
        <button class="button" type="button" id="resetBtn" onclick="reset()">Reset</button>
        <a class="button" id="dl" onclick="exportImg()"><button type="button">Export</button></a>

        <!--  -->

      </td>
      <td id="srcErr"></td>
    </tr>
    </tbody>
  </table>
</div>

  </body>
  <script type="text/javascript">
      let imgElement = document.getElementById('srcImage');
      let inputElement = document.getElementById('fileInput');
      inputElement.addEventListener("change", (e) => {
          imgElement.src = URL.createObjectURL(e.target.files[0]);
      }, false);

      imgElement.onload = function() {
          let mat = cv.imread(imgElement);
          cv.imshow('outputCanvas', mat);
          mat.delete();
      };

      gray = false;
      hsv = false;

      // var bin_inv = new BinaryThresh();
      // var b_threshold_inv = gui.addFolder("Binary Threshold Inv");
      // b_threshold_inv.add(bin_inv, 'thresh', 0, 255).onChange( function(val) {
      //     let mat = cv.imread(imgElement);
      //     if (gray) {
      //       cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);
      //     }
      //     if (hsv) {
      //       cv.cvtColor(mat, mat, cv.COLOR_RGB2HSV, 0);
      //     }
      //     cv.threshold(mat, mat, val, bin.alpha, cv.THRESH_BINARY_INV);
      //     cv.imshow('outputCanvas', mat);
      //     mat.delete();
      // });
      // b_threshold_inv.add(bin_inv, 'alpha', 0, 255).onChange( function(val) {
      //     let mat = cv.imread(imgElement);
      //     if (gray) {
      //       cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);
      //     }
      //     if (hsv) {
      //       cv.cvtColor(mat, mat, cv.COLOR_RGB2HSV, 0);
      //     }
      //     cv.threshold(mat, mat, bin.thresh, val, cv.THRESH_BINARY_INV);
      //     cv.imshow('outputCanvas', mat);
      //     mat.delete();
      // });
      //
      //
      // b_threshold_inv.open();


      function openCvReady() {
        cv['onRuntimeInitialized']=()=>{
          console.log( 'OpenCV Ready', cv);
          document.getElementById('status').style.display = 'none';
          document.getElementById('imageTable').style.display = 'block';


          let imgElement = document.getElementById('srcImage')
          imgElement.src = 'gfx/cs460.png';

          imgElement.onload = function() {
              let mat = cv.imread(imgElement);
              cv.imshow('outputCanvas', mat);
              mat.delete();
          };

          var Thresh = function() {
              this.thresh =  127;
              this.alpha =  255;
              this.type = 'Binary';
              this.code = cv.THRESH_BINARY;
              this.block = 3;
              this.c = 0;
              this.adaptiveM = false;
              this.adaptiveG = false;
              this.adapt = cv.ADAPTIVE_THRESH_MEAN_C
          };

          controller = {
              "Gray": function(){
                  gray = true;
                  if (isCanvasBlank(document.getElementById('outputCanvas'))) {
                      let mat = cv.imread(imgElement);
                      cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY);
                      cv.imshow('outputCanvas', mat);
                      mat.delete();
                  }
                  else {
                      let mat = cv.imread(document.getElementById('outputCanvas'));
                      cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY);
                      cv.imshow('outputCanvas', mat);
                      mat.delete();
                  }
              },
              "HSV": function(){
                  hsv = true;
                  if (isCanvasBlank(document.getElementById('outputCanvas'))) {
                      let mat = cv.imread(imgElement);
                      cv.cvtColor(mat, mat, cv.COLOR_RGB2HSV);
                      cv.imshow('outputCanvas', mat);
                      mat.delete();
                  }
                  else {
                      let mat = cv.imread(document.getElementById('outputCanvas'));
                      cv.cvtColor(mat, mat, cv.COLOR_RGB2HSV);
                      cv.imshow('outputCanvas', mat);
                      mat.delete();
                  }
              }
          }

          var gui = new dat.GUI();
          gui.domElement.id = 'gui';
          var colors = gui.addFolder( "Colors" );
          colors.add( controller, 'Gray' );
          colors.add( controller, 'HSV' );
          colors.open();
          var b_threshold = gui.addFolder("Threshold");
          var bin = new Thresh();
          bin.type = cv.THRESH_BINARY;
          var threshType = b_threshold.add(bin, 'type', ['Binary', 'Binary Inv',
             'Trunc', 'To Zero', 'Otsu', 'Triangle']).name('Type').listen();
          threshType.setValue('Binary');
          threshType.onChange(function(val) {
              bin.type = val;
              switch(val) {
                  case 'Binary': bin.code = cv.THRESH_BINARY;break;
                  case 'Binary Inv': bin.code = cv.THRESH_BINARY_INV;break;
                  case 'Trunc': bin.code = cv.THRESH_TRUNC;break;
                  case 'To Zero': bin.code = cv.THRESH_TOZERO;break;
                  case 'Otsu': bin.code = cv.THRESH_OTSU;gray=true;break;
                  case 'Triangle': bin.code = cv.THRESH_TRIANGLE;gray=true;break;
              }
          });
          var adaptM = b_threshold.add(bin, 'adaptiveM').name('Adaptive Mean').listen();
          var adaptG = b_threshold.add(bin, 'adaptiveG').name('Adaptive Gau').listen();
          adaptM.onChange(function(val) {
            bin.adaptiveM = val;
            if (val) {
              bin.adaptiveG = false;
            }
          });
          adaptG.onChange(function(val) {
            bin.adaptiveG = val;
            if (val) {
              bin.adaptiveM = false;
            }
          });
          b_threshold.add(bin, 'thresh', 0, 255).name('Thresh').onChange( function(val) {
              if(bin.adaptiveM || bin.adaptiveG){
                return;
              }
              let mat = cv.imread(imgElement);
              if (gray) {
                  cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);
              }
              if (hsv) {
                  cv.cvtColor(mat, mat, cv.COLOR_RGB2HSV, 0);
              }
              cv.threshold(mat, mat, val, bin.alpha, bin.code);
              cv.imshow('outputCanvas', mat);
              mat.delete();
          });
          b_threshold.add(bin, 'alpha', 0, 255).name('Max Val').onChange( function(val) {
              let mat = cv.imread(imgElement);
              if (gray) {
                  cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);
              }
              if (hsv) {
                  cv.cvtColor(mat, mat, cv.COLOR_RGB2HSV, 0);
              }
              if((bin.adaptiveM || bin.adaptiveG) && (bin.type == 'Binary' || bin.type == 'Binary Inv')){
                if(bin.adaptiveM){
                  cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);
                  cv.adaptiveThreshold(mat, mat, val, cv.ADAPTIVE_THRESH_MEAN_C, bin.code, bin.block, bin.c);
                  gray = true;
                }
                else {
                  cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);
                  cv.adaptiveThreshold(mat, mat, val, cv.ADAPTIVE_THRESH_GAUSSIAN_C, bin.code, bin.block, bin.c);
                  gray = true;
                }
              }
              else {
                cv.threshold(mat, mat, bin.thresh, val, bin.code);
              }
              cv.imshow('outputCanvas', mat);
              mat.delete();
          });
          b_threshold.open();
        };
      }

      // function addTransformation() {
      //   if(isCanvasBlank(document.getElementById('outputCanvas'))) {
      //       document.getElementById('srcErr').innerHTML = 'Can not copy blank canvas.';
      //       return;
      //   }
      //     document.getElementById('srcErr').innerHTML = '';
      //
      //     var table = document.getElementById("imageTable");
      //     var row = table.insertRow(0);
      //     var cell1 = row.insertCell(0);
      //     var cell2 = row.insertCell(1);
      //     let mat1 = cv.imread(document.getElementById('srcImage'));
      //     let mat2 = cv.imread(document.getElementById('outputCanvas'));
      //
      //     cell1.innerHTML = '<canvas id="newCanvas1"><canvas>'
      //     cell2.innerHTML = '<canvas id="newCanvas2"><canvas>'
      //     cv.imshow('newCanvas1', mat1);
      //     cv.imshow('newCanvas2', mat2);
      //     cv.imshow('srcImage'.src, mat2);
      //
      //
      //     mat1.delete();
      //     mat2.delete();
      // }

      function reset() {
          let mat = cv.imread(imgElement);
          cv.imshow('outputCanvas', mat);
          mat.delete();
          gray = false;
          hsv = false;

      }

      function exportImg() {
          var dl = document.getElementById('dl');
          var canvas = document.getElementById('outputCanvas');
          var dataURL = canvas.toDataURL('image/jpeg', 1.0).replace("image/png", "image/octet-stream");

          dl.setAttribute('download', 'export.png');
          dl.setAttribute('href', dataURL);
      }

      function isCanvasBlank(canvas) {
          const context = canvas.getContext('2d');

          const pixelBuffer = new Uint32Array(
              context.getImageData(0, 0, canvas.width, canvas.height).data.buffer
          );

          return !pixelBuffer.some(color => color !== 0);
      }

  </script>

</html>
